#vim go ide setup, bash code below
export GOPATH=$HOME/.go
export PATH=$PATH:$GOPATH/bin

#if mac, ubuntu use apt-get install go
brew install go
"go get" the basics
go get golang.org/x/tools/cmd/godoc

#install pathogen
mkdir -p ~/.vim/autoload ~/.vim/bundle
curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim
#install vim-go-ide into vim, pathogen will automatically load the module
git clone https://github.com/farazdagi/vim-go-ide.git ~/.vim_go_runtime
sh ~/.vim_go_runtime/bin/install
#run vim in ide mode for go
vim -u ~/.vimrc.go
#install necessary binaries for go ide to work(important), if run into problem of not finding the import path for modules, check the GOROOT, try unset it
in vim run ":GoInstallBinaries"



go run helloworld.go

godoc fmt println //this cmd shows you the println function under package godoc



//string manipulation
strings.HasPrefix(the_str, str_pattern)
strings.Split(the_str, separator)



//testing utility
func equals(t *testing.T, actual interface{}, expected interface{}) {
    if actual != expected {
        t.Error("Expected >%s<, actual >%s<", expected, actual)
    }
}
func fail(t *testing.T, err error, expected_err_string string) {
    if err.Error() != expected_err_string {
        t.Error("Expected >%s<, actual >%s<", expected_err_string, err.Error())
    }
}
func ok(t *testing.T, actual_error error) {
    if actual_error != nil {
        t.Error("unexpected error raised %s", actual_error)
    }
}


example code:


package main
import (
    "fmt"
    "math"
    "errors"
)

type person struct{
    name string
    age int

}

func main(){
    fmt.Println("hello world")
    //x:=5
    var x int = 5
    fmt.Println(x)
    if x <6 {
        fmt.Println("false")
    }

    //var a [5]int
    var a []int
    a = append(a,5)

    //when no number assigned to array, it's a slice, variable length
    //var a [5]int{5,4,3,2,1}
    //a[2] = 7
    //a = append(a,110)
    fmt.Println(a)


    key_value_pair := make(map[string]int)
    key_value_pair["key1"] = 2
    key_value_pair["key2"] = 3
    delete(key_value_pair, "key2")
    fmt.Println(key_value_pair)

    for i := 0; i < 5; i++{
        fmt.Println(i)
    }
    
        //while loop
    //i := 0
    //for i < 5 {
    //    fmt.Println(i)
    //}

    m := make(map[string]string)
    m["a"] = "alpha"
    m["b"] = "alpha"
    for key, value := range m{
        fmt.Println("key:",key, "value:",value)
    }

    result := sum(2,3)
    fmt.Println(result)

    sqrt_res, err := sqrt(16)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(sqrt_res)
    p := person{name: "", age: 23}
    fmt.Println(p)


    ab :=7
    fmt.Println(&ab)
    //pass in the address of the pointer
    increase(&ab)
    fmt.Println(ab)

}

func increase(x *int){
    //dereference the pointer address
    *x++
}

func sum(x int, y int) int {
    return x+y

}

func sqrt(x float64) (float64, error){
    if x < 0 {
        return 0, errors.New("undefined for negative")
    }
    return math.Sqrt(x), nil
}



//method
func sayHello(){
    fmt.Println("hello")
}

//type struct, think struct as a class

type person struct{
    firstname String //struct variable
    lastname String //struct variable
    //we want a speak method for person struct
}
//this method defined a class method for person
func(p person) speak(){
    fmt.Println("i m human")
}

type secretAgent struct{
    person //this struct inherit person struct, now u can call secretAgentIns.firstname ... etc
    licenceToKill bool //added class variable
}

//overwrite the speak() method for secretAgent
func(s secretAgent) speak(){
    fmt.Println('i m james bond')
}

//interface: with the person and secretAgent struct in the scope, now we want to generalize both person and secretAgent
//to be a human class, in goland, this is called interface
type human interface{
    //this speak() defined that "every struct has this speak() method is now a human abstract class"
    speak()
}

//now we have a human interface, we can take any human interface and call its speak function)
func saySomething(h human){
    h.speak()
}

//a pointer receiver, this will enable this method to have the real person struct, so you can modify its value;
//if not a pointer receiver, the p(person struct) will be a copy of original person struct, any modify is to the copy of the struct not itself.
func(p *person) changeFirstName(newFirstName string) {
    p.firstname = newFirstName
}

//golang type conversion
p=person{"joe","underwood"}
secAgen := p.(secretAgent) //this converts the person type to secret agent


//empty interface to deal with multiple type problem
//type switch
var emptyInterface interface{} = 0 //this time we defined an empty interface and assign 0(int) to it
switch emptyInterface.(type) {
    case int: fmt.Println("i m an int")
    case float64: fmt.Println("i m an float64")
}

    
//when in terms of defining a new var for interface, if you have defined a pointer receiver interface, it would work with either pointer receiver method implementation, or value method implementation
var i = *someInterface{}
//but when defined a value interface
var i = someInterface{}//this will require underlying method implementation to be all value . func(i someInterface) someMethod(){}

    
    
//best way to concatenate string, bytes
package main

import (
    "bytes"
    "fmt"
)

func main() {
    var buffer bytes.Buffer

    for i := 0; i < 1000; i++ {
        buffer.WriteString("a")
        //buffer.Wirte([]bytes) this also works for bytes
    }

    fmt.Println(buffer.String())
}
    
    
    
