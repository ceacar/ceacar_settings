
go run helloworld.go

godoc fmt println //this cmd shows you the println function under package godoc



//string manipulation
strings.HasPrefix(the_str, str_pattern)
strings.Split(the_str, separator)



//testing utility
func equals(t *testing.T, actual interface{}, expected interface{}) {
    if actual != expected {
        t.Error("Expected >%s<, actual >%s<", expected, actual)
    }
}
func fail(t *testing.T, err error, expected_err_string string) {
    if err.Error() != expected_err_string {
        t.Error("Expected >%s<, actual >%s<", expected_err_string, err.Error())
    }
}
func ok(t *testing.T, actual_error error) {
    if actual_error != nil {
        t.Error("unexpected error raised %s", actual_error)
    }
}


example code:


package main
import (
    "fmt"
    "math"
    "errors"
)

type person struct{
    name string
    age int

}

func main(){
    fmt.Println("hello world")
    //x:=5
    var x int = 5
    fmt.Println(x)
    if x <6 {
        fmt.Println("false")
    }

    //var a [5]int
    var a []int
    a = append(a,5)

    //when no number assigned to array, it's a slice, variable length
    //var a [5]int{5,4,3,2,1}
    //a[2] = 7
    //a = append(a,110)
    fmt.Println(a)


    key_value_pair := make(map[string]int)
    key_value_pair["key1"] = 2
    key_value_pair["key2"] = 3
    delete(key_value_pair, "key2")
    fmt.Println(key_value_pair)

    for i := 0; i < 5; i++{
        fmt.Println(i)
    }
    
        //while loop
    //i := 0
    //for i < 5 {
    //    fmt.Println(i)
    //}

    m := make(map[string]string)
    m["a"] = "alpha"
    m["b"] = "alpha"
    for key, value := range m{
        fmt.Println("key:",key, "value:",value)
    }

    result := sum(2,3)
    fmt.Println(result)

    sqrt_res, err := sqrt(16)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(sqrt_res)
    p := person{name: "", age: 23}
    fmt.Println(p)


    ab :=7
    fmt.Println(&ab)
    //pass in the address of the pointer
    increase(&ab)
    fmt.Println(ab)

}

func increase(x *int){
    //dereference the pointer address
    *x++
}

func sum(x int, y int) int {
    return x+y

}

func sqrt(x float64) (float64, error){
    if x < 0 {
        return 0, errors.New("undefined for negative")
    }
    return math.Sqrt(x), nil
}



//method
func sayHello(){
    fmt.Println("hello")
}

//type struct, think struct as a class

type person struct{
    firstname String //struct variable
    lastname String //struct variable
    //we want a speak method for person struct
}
//this method defined a class method for person
func(p person) speak(){
    fmt.Println("i m human")
}

type secretAgent struct{
    person //this struct inherit person struct, now u can call secretAgentIns.firstname ... etc
    licenceToKill bool //added class variable
}

//overwrite the speak() method for secretAgent
func(s secretAgent) speak(){
    fmt.Println('i m james bond')
}

//interface: with the person and secretAgent struct in the scope, now we want to generalize both person and secretAgent
//to be a human class, in goland, this is called interface
type human interface{
    //this speak() defined that "every struct has this speak() method is now a human abstract class"
    speak()
}

//now we have a human interface, we can take any human interface and call its speak function)
func saySomething(h human){
    h.speak()
}

//a pointer receiver, this will enable this method to have the real person struct, so you can modify its value;
//if not a pointer receiver, the p(person struct) will be a copy of original person struct, any modify is to the copy of the struct not itself.
func(p *person) changeFirstName(newFirstName string) {
    p.firstname = newFirstName
}

//golang type conversion
p=person{"joe","underwood"}
secAgen := p.(*secretAgent) //this converts the person type to secret agent


    
    
    
    
    
    
    
    
