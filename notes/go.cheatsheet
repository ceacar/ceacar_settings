#vim go ide setup, bash code below
export GOPATH=$HOME/.go
export PATH=$PATH:$GOPATH/bin

#if mac, ubuntu use apt-get install go
brew install go
#optional?
"go get" the basics
#optional?
go get golang.org/x/tools/cmd/godoc

#install pathogen
mkdir -p ~/.vim/autoload ~/.vim/bundle
curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim
#install vim-go-ide into vim, pathogen will automatically load the module
git clone https://github.com/farazdagi/vim-go-ide.git ~/.vim_go_runtime
sh ~/.vim_go_runtime/bin/install
#run vim in ide mode for go
vim -u ~/.vimrc.go
#install necessary binaries for go ide to work(important), if run into problem of not finding the import path for modules, check the GOROOT, try unset it
in vim run ":GoInstallBinaries"
#put below line into ~/.vimrc.go
set t_Co=256


go run helloworld.go

godoc fmt println //this cmd shows you the println function under package godoc


//remove new line from string
read_line = read_line[:len(read_line)-1]
//Perhaps a better approach is to use the strings library:
read_line = strings.TrimSuffix(read_line, "\n")


//string manipulation
strings.HasPrefix(the_str, str_pattern)
strings.Split(the_str, separator)

//initialize map[string][]string
mapOfSlices := map[string][]string{
    "first": {},
    "second": []string{"one", "two", "three", "four", "five"},
    "third": []string{"quarter", "half"},
}

//golang datetime formatting
package main

import (
    "fmt"
    "time"
)

func main() {
    layout1 := "03:04:05PM"
    layout2 := "15:04:05"
    t, err := time.Parse(layout1, "07:05:45PM")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(t.Format(layout1))
    fmt.Println(t.Format(layout2))
}


//testing utility
func equals(t *testing.T, actual interface{}, expected interface{}) {
    if actual != expected {
        t.Error("Expected >%s<, actual >%s<", expected, actual)
    }
}
func fail(t *testing.T, err error, expected_err_string string) {
    if err.Error() != expected_err_string {
        t.Error("Expected >%s<, actual >%s<", expected_err_string, err.Error())
    }
}
func ok(t *testing.T, actual_error error) {
    if actual_error != nil {
        t.Error("unexpected error raised %s", actual_error)
    }
}


example code:


package main
import (
    "fmt"
    "math"
    "errors"
)

type person struct{
    name string
    age int

}

func main(){
    fmt.Println("hello world")
    //x:=5
    var x int = 5
    fmt.Println(x)
    if x <6 {
        fmt.Println("false")
    }

    //var a [5]int
    var a []int
    a = append(a,5)

    //when no number assigned to array, it's a slice, variable length
    //var a [5]int{5,4,3,2,1}
    //a[2] = 7
    //a = append(a,110)
    fmt.Println(a)


    key_value_pair := make(map[string]int)
    key_value_pair["key1"] = 2
    key_value_pair["key2"] = 3
    delete(key_value_pair, "key2")
    fmt.Println(key_value_pair)

    for i := 0; i < 5; i++{
        fmt.Println(i)
    }
    
        //while loop
    //i := 0
    //for i < 5 {
    //    fmt.Println(i)
    //}

    m := make(map[string]string)
    m["a"] = "alpha"
    m["b"] = "alpha"
    for key, value := range m{
        fmt.Println("key:",key, "value:",value)
    }

    result := sum(2,3)
    fmt.Println(result)

    sqrt_res, err := sqrt(16)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(sqrt_res)
    p := person{name: "", age: 23}
    fmt.Println(p)


    ab :=7
    fmt.Println(&ab)
    //pass in the address of the pointer
    increase(&ab)
    fmt.Println(ab)

}

func increase(x *int){
    //dereference the pointer address
    *x++
}

func sum(x int, y int) int {
    return x+y

}

func sqrt(x float64) (float64, error){
    if x < 0 {
        return 0, errors.New("undefined for negative")
    }
    return math.Sqrt(x), nil
}



//method
func sayHello(){
    fmt.Println("hello")
}

//type struct, think struct as a class

type person struct{
    firstname String //struct variable
    lastname String //struct variable
    //we want a speak method for person struct
}
//this method defined a class method for person
func(p person) speak(){
    fmt.Println("i m human")
}

type secretAgent struct{
    person //this struct inherit person struct, now u can call secretAgentIns.firstname ... etc
    licenceToKill bool //added class variable
}

//overwrite the speak() method for secretAgent
func(s secretAgent) speak(){
    fmt.Println('i m james bond')
}

//interface: with the person and secretAgent struct in the scope, now we want to generalize both person and secretAgent
//to be a human class, in goland, this is called interface
type human interface{
    //this speak() defined that "every struct has this speak() method is now a human abstract class"
    speak()
}

//delete element from map a
delete(aMap, key)

//now we have a human interface, we can take any human interface and call its speak function)
func saySomething(h human){
    h.speak()
}

//a pointer receiver, this will enable this method to have the real person struct, so you can modify its value;
//if not a pointer receiver, the p(person struct) will be a copy of original person struct, any modify is to the copy of the struct not itself.
func(p *person) changeFirstName(newFirstName string) {
    p.firstname = newFirstName
}

//golang type conversion
p=person{"joe","underwood"}
secAgen := p.(secretAgent) //this converts the person type to secret agent


//empty interface to deal with multiple type problem
//type switch
var emptyInterface interface{} = 0 //this time we defined an empty interface and assign 0(int) to it
switch emptyInterface.(type) {
    case int: fmt.Println("i m an int")
    case float64: fmt.Println("i m an float64")
}

    
//when in terms of defining a new var for interface, if you have defined a pointer receiver interface, it would work with either pointer receiver method implementation, or value method implementation
var i = *someInterface{}
//but when defined a value interface
var i = someInterface{}//this will require underlying method implementation to be all value . func(i someInterface) someMethod(){}

    
    
//best way to concatenate string, bytes
package main

import (
    "bytes"
    "fmt"
)

func main() {
    var buffer bytes.Buffer

    for i := 0; i < 1000; i++ {
        buffer.WriteString("a")
        //buffer.Wirte([]bytes) this also works for bytes
    }

    fmt.Println(buffer.String())
}
    
    
//read file

package main

import (
    "compress/gzip"
    "encoding/csv"
    "fmt"
    "log"
    "os"
)

func main() {
    f, err := os.Open("data.csv.gz")
    if err != nil {
        log.Fatal(err)
    }
    defer f.Close()
    gr, err := gzip.NewReader(f)
    if err != nil {
        log.Fatal(err)
    }
    defer gr.Close()

    cr := csv.NewReader(gr)
    rec, err := cr.Read()
    if err != nil {
        log.Fatal(err)
    }
    for _, v := range rec {
        fmt.Println(v)
    }
}



//go testing 
//benchmark

func BenchmarkXxx(*testing.B)
are considered benchmarks, and are executed by the "go test" command when its -bench flag is provided. Benchmarks are run sequentially.

For a description of the testing flags, see https://golang.org/cmd/go/#hdr-Description_of_testing_flags.

A sample benchmark function looks like this:

func BenchmarkHello(b *testing.B) {
    for i := 0; i < b.N; i++ {
        fmt.Sprintf("hello")
    }


//reset benchmark timer
b.ResetTimer()



//vim-go fast add qutoe to a word
ciw"Ctrl+r" //this cmd is type ciw in normal mode will delete word, and manually type ", and then press ctrl+r" to paste what is last deleted
//outside vim-go fast add quote
ciw'Ctrl+r"'

//check if map has this element
if _, ok := groupSet["sip"]; ok {
    //do stuff
}



//go routine sync waiting
package main

import "fmt"
import "sync"


var wg sync.WaitGroup // 1
func cleanup(){
    if r := recover(); r!=nil {
        fmt.Println("recovered",r)
    }
}
func routine(i int) {
    defer wg.Done() // 3
    defer cleanup()
    fmt.Printf("routine %v finished\n", i)
    if i ==2 {
    panic("2 should not be in here")
    }
}

func main() {
    for i := 0; i < 10; i++ {
        wg.Add(1) // 2
        go routine(i) // *
    }
    wg.Wait() // 4
    fmt.Println("main finished")
}

//go routine channel
package main
import "fmt"
import "sync"

var wg sync.WaitGroup
func foo(c chan int, v int){
    defer wg.Done()
    c <- v*5
}
func main(){
    channelIns := make(chan int, 10)
    for i :=0; i< 10;i++{
        wg.Add(1)
        go foo(channelIns, i)
    }
    //go foo(channelIns, 5)
    //go foo(channelIns, 3)
    //v1 := <- channelIns
    //v2 := <- channelIns
    //fmt.Println(v1, v2)
    wg.Wait()
    //only close channel after nothing will send to channel
    close(channelIns)
    for item := range channelIns{
        fmt.Println(item)
    }
}


//in go only have pass by value, everything is duplicated when passing around, so use pointer
import (
    "fmt"
)

type Point struct {
    x int
    y int
}

func (p Point) String() string {
    return fmt.Sprintf("(%d, %d)", p.x, p.y)
}

func modifyValue(point Point) {
    point.x += 10
}

func modifyPointer(point *Point) {
    point.x = 5
    point.y = 5
}

func modifyReference(point *Point) {
    point = &Point{5, 5}
}

func main() {
    p := Point{0, 0}
    fmt.Println(p) // prints (0, 0)

    modifyValue(p)
    fmt.Println(p) // prints (0, 0)

    modifyPointer(&p)
    fmt.Println(p) // prints (5, 5)

    p = Point{0, 0}
    modifyReference(&p)
    fmt.Println(p) // prints (0, 0)
}

//check if string is in a string
strings.Contains("something", "some") // true



testing:
1.navigate to source code package dir
2.run go tool cover -html=c.out
3. if not sucessful, run touch c.out, then try again, if successful, you should see message like 
HTML output written to /tmp/cover716341004/coverage.html
4.now checkout the file generated above, in this case it is at "/tmp/cover716341004/coverage.html"
5. now color coding is through a class called covX, known one is cov0, this means not covered, cov8 means covered
<span class="cov0" title="0">{
                fmt.Errorf("%s", err.Error())
                return []string{}, 1, err
}</span>
above code means the part code of golang error handling is not covered


//string to bool
b, err := strconv.ParseBool("true")
//string to float
f, err := strconv.ParseFloat("3.1415", 64)
//string to int
i, err := strconv.ParseInt("-42", 10, 64)
//string to int
u, err := strconv.ParseUint("42", 10, 64)
