#functional programming
from functools import partial
from operator import add
def add1(x):
  return add(1,x)
#above function can be written as below
add1=partial(add,1) 

#lazy evaluation trick

#iterators
iter(x)
#calls next
next(x)

#this will only evaluate when it is called(in some sequence)
def lazy_integers(n=0):
  while True:
    yield n
  n+1
xs=lazy_integers()
[next(xs) for _ in range(10)]

#generator comprehensions
squares=(x**2 for x in lazy_integers())
next(squares)



#itertools

#count lazy eval
from itertools import count
count([start=0,[step=1]) #start, start+step, start+2*step, ...
#islice is a lazy eval of returning a part of a list
from itertools improt islice
islice(seq, [start=0], stop, [ste=1])
#copies a iterator
tee(it,[n=2])
#repeat
repeat(it,[n=forever])
#cycle = repeat forever
cycle(p)
#chain
chain(a,b,...)
#accumulate, similar to reduce in scala
from itertools import accumulate
accumulate(p,[func=add])

################TOOLZ###############################
#http://toolz.readthedocs.io/en/latest/api.html#toolz.functoolz.compose
#compose n functions
import toolz
>>> inc = lambda i: i + 1
import toolz.functoolz.compose(str, inc)(3)
'4'

#this is the same as f(g(h(x, y)))
toolz.functoolz.compose(f, g, h)(x, y)


#equivalent of h(g(f(data)))
toolz.functoolz.pipe(data, f, g, h)

#function that converts binary output to true or false
toolz.functoolz.complement(function_of_binary_output)

#converts any function to composable function
#toolz.functoolz.do(func, x)
>>> from toolz import compose
>>> from toolz.curried import do
>>> log = []
>>> inc = lambda x: x + 1
>>> inc = compose(inc, do(log.append))
>>> inc(1)
2
>>> inc(11)
12
>>> log
[1, 11]


  #manual implementation:
  #import functools
  #def compose(*functions):
  #    def compose2(f, g):
  #        return lambda x: f(g(x))
  #    #applies compose2 to each functions and initial value is lambda x:x  which is anonymous function of returning original
  #    return functools.reduce(compose2, functions, lambda x: x)
  ##the order the from right to left since it's a reduce function
  #composed_func = compose(str,lambda x: x*x, lambda x:x*2)
  #print composed_func(10)




#install specific version of dependency
pip install django_modeltranslation==0.4.0-beta2

#merge two json, or update one json with another json
c = {key: value for (key, value) in (a.items() + b.items())}
#loads json string to json
obj = json.loads(json_string) 
