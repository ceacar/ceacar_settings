#!/bin/bash

#get script name
script_name=`basename "$0"`

#get all argument except the last
length=$(($#-1))
array=${@:1:$length}

#split argument for first n-1 and last 1
function run_and_memo(){ local length=$(($#-1))
  local array=${@:1:$length}
  local cmd_to_run=$(echo $array)
  local cmd2="${@: -1}"
  #echo "$cmd_to_run"
  $cmd_to_run
  $cmd2
}

 #file descriptor as a output file
exec 3>> output.txt
echo "f1"
echo >&2 "f2"
echo "f3" >&3
echo "f4" >&3



#run cmd under other user
su -l -s /bin/sh fbd -c 'pwd'


#get dates
date +%Y%m%d -d "-1 days"

#parallel syntax
parallel --retries 5 -j $(nproc) --halt=2 --block $your_chunk_size --pipe $cmd
#trap
trap 'echo "job error"' ERR #will echo when job errored
trap 'echo "job error"' EXIT #will echo regardless what is the exit status


#find ip address of host
hostname -I

#fix the issue tmux not connected to the old same agent when reconnect
#create ~/.ssh/rc if it doesn't exist yet, and add the following content:'
#!/bin/bash

# Fix SSH auth socket location so agent forwarding works with tmux
if test "$SSH_AUTH_SOCK" ; then
  ln -sf $SSH_AUTH_SOCK ~/.ssh/ssh_auth_sock
fi
#Make it work in tmux, add this to your ~/.tmux.conf:
# fix ssh agent when tmux is detached
setenv -g SSH_AUTH_SOCK $HOME/.ssh/ssh_auth_sock




#curl cheats
#With fields:
curl --data "param1=value1&param2=value2" https://example.com/resource.cgi
#With fields specified individually:
curl --data "param1=value1" --data "param2=value2" https://example.com/resource.cgi
#Multipart:
curl --form "fileupload=@my-file.txt" https://example.com/resource.cgi
#Multipart with fields and a filename:
curl --form "fileupload=@my-file.txt;filename=desired-filename.txt" --form param1=value1 --form param2=value2 https://example.com/resource.cgi
#Without data:
curl --data '' https://example.com/resource.cgi
curl -X POST https://example.com/resource.cgi
curl --request POST https://example.com/resource.cgi


#operators
[[ -n str_input ]] #checking string input is not null



#netcat
docker inspect [docker container NAME] 
nc.traditional -l "38003" -c "nc.tradditional 172.19.0.16 8080" #nc listens to the port 38003 and it writes what it heard through port 38003 to the host at 172.19.0.16.8080 


nc -l port1 | nc host port # this will listen to port1 then write the content it heard through the port 1 to the port of the host 



#ssh tunneling notes
#Introduction
#local: -L Specifies that the given port on the local (client) host is to be forwarded to the given host and port on the remote side.
#
ssh -L sourcePort:forwardToHost:onPort connectToHost means: connect with ssh to connectToHost, and forward all connection attempts to the local sourcePort to port onPort on the machine called forwardToHost, which can be reached from the connectToHost machine.
#
#remote: -R Specifies that the given port on the remote (server) host is to be forwarded to the given host and port on the local side.
#
ssh -R sourcePort:forwardToHost:onPort connectToHost means: connect with ssh to connectToHost, and forward all connection attempts to the remote sourcePort to port onPort on the machine called forwardToHost, which can be reached from your local machine.
#
#Additional options
#-f tells ssh to background itself after it authenticates, so you don't have to sit around running something on the remote server for the tunnel to remain alive.
#-N says that you want an SSH connection, but you don't actually want to run any remote commands. If all you're creating is a tunnel, then including this option saves resources.
#-T disables pseudo-tty allocation, which is appropriate because you're not trying to create an interactive shell.

#generalized format of ssh tunneling
#-L is read from left to right
#-R is read from right to left, like from intermediatehost tunnel the port host_of_receiving:port to the localhost with port host_of_initiation_port
ssh -L host_of_initiation_port:host_of_receiving:port intermediatehost
ssh -R host_of_initiation_port:host_of_receiving:port intermediatehost
#assume you want to map a local port 123 to remote server's port 456
ssh -L 123:remote_host:456 remotehost
#assume you want to map a remote server's port 456 to localhost's port 123
ssh -R 456:localhost:123 remote_host

